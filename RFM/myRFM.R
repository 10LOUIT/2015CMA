# __________________________________________________________
# //////////////////////////////////////////////////////////
#
#    MODULE 2 - MANAGERIAL SEGMENTATION
# __________________________________________________________
# //////////////////////////////////////////////////////////


# --- COMPUTING RECENCY, FREQUENCY, MONETARY VALUE ---------


# ------------------ Call the rfm segmentation function and return the processed df ------------------
# All Customers
#customers <- rfmSegmentation(data, 150)
# Customers with purchase in 2014
customers_2014 <- rfmSegmentation(data, 150, 0)
# Customers with purchase in 2012
customers_2013 <- rfmSegmentation(data, 150, 365)
# Customers with purchase in 2011
customers_2012 <- rfmSegmentation(data, 150, 730)

# --- PREPARING AND TRANSFORMING DATA ----------------------

# Copy customer data into new data frame
#new2_data = sqldf("SELECT * FROM customers WHERE amount > 0")
#summary(new2_data)

# Remove customer id as a variable, store it as row names
# head(new2_data)
# row.names(new2_data) = new_data2$customer_id
# new2_data$customer_id = NULL
# head(new2_data)

# Take the log-transform of the amount, and plot
# new_data2$amount = log(new_data$amount)
# hist(new2_data$amount)

# Standardize variables
# new_data2 = scale(new_data)
# head(new2_data)

# Data Exploration and visualization
myPieChart(customers_2014, "Pie Chart of Customer Segments\n (RFM)")
aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)

# Explore the data
head(customers_2014)
summary(customers_2014)
hist(customers_2014$recency)
hist(customers_2014$frequency)
hist(customers_2014$amount)
hist(customers_2014$amount, breaks = 100)

# --- SEGMENTING A DATABASE RETROSPECTIVELY ----------------
# Segment customers with transactions in the previous year
#customers_2012 <- rfmSegmentation(data, 150, 365)

# Show segmentation results
myPieChart(customers_2012, "Pie Chart of Customer Segments\n (RFM 2012)")
aggregate(x = customers_2012[, 2:5], by = list(customers_2012$segment), mean)

# --- COMPUTING REVENUE GENERATION PER SEGMENT -------------

# Compute how much revenue is generated by segments
# Notice that people with no revenue in 2013 do NOT appear
revenue_2014 = sqldf("SELECT customer_id, SUM(purchase_amount) AS 'revenue_2014'
                      FROM data
                      WHERE year_of_purchase = 2014
                      GROUP BY 1")
summary(revenue_2014)

# Merge 2014 customers and 2014 revenue (correct)
actual = merge(customers_2014, revenue_2014, all.x = TRUE)
actual$revenue_2014[is.na(actual$revenue_2014)] = 0
myPieChart(actual, "Pie Chart of Customer Segments\n (actual RFM 2014)")

# Show average revenue per customer and per segment
actual_aggregation = aggregate(x = actual$revenue_2014, by = list(customers_2014$segment), mean)
# Re-order and display results
actual_aggregation = actual_aggregation[order(actual_aggregation$x, decreasing = TRUE), ]
print(actual_aggregation)
barplot(actual_aggregation$x, names.arg = actual_aggregation$Group.1, legend.text = round(actual_aggregation$x, 2), xlab = "Customer Segments", ylab = "Average revenue", col = c("darkgreen","green","orange","yellow","darkblue","blue","red"), main="Average revenue per customer and per segment")

# Show total revenue per customer and per segment
actual_total = aggregate(x = actual$revenue_2014, by = list(customers_2014$segment), sum)
actual_total = actual_total[order(actual_total$x, decreasing = TRUE), ]
myBoxplot(actual_total, "Total revenue per customer and per segment", "Customer Segments", "Total revenue")
#barplot(actual_total$x, names.arg = actual_total$Group.1, legend.text = round(actual_total$x, 2), xlab = "Customer Segments", ylab = "total revenue", col = c("darkgreen","green","orange","yellow","darkblue","blue","red"), main="Total revenue per customer and per segment")

# Merge 2013 customers and 2014 revenue (correct)
forward = merge(customers_2013, revenue_2014, all.x = TRUE)
forward$revenue_2014[is.na(forward$revenue_2014)] = 0

# Compute RFM variables as of a year ago (Enhanced)
customers_2013 = sqldf("SELECT customer_id,
                       MIN(days_since) - 365 AS 'recency',
                       MAX(days_since) - 365 AS 'first_purchase',
                       COUNT(*) AS 'frequency',
                       AVG(purchase_amount) AS 'avg_amount',
                       MAX(purchase_amount) AS 'max_amount'
                       FROM data
                       WHERE days_since > 365
                       GROUP BY 1")

# Merge 2013 customers and 2014 revenue (Enhanced)
in_sample = merge(customers_2013, revenue_2014, all.x = TRUE)
in_sample$revenue_2014[is.na(in_sample$revenue_2014)] = 0
in_sample$active_2014 = as.numeric(in_sample$revenue_2014 > 0)

# Display calibration (in-sample) data
head(in_sample)
summary(in_sample)

# --- CALIBRATE THE MODELS ---------------------------------


# Calibrate probability model
library(nnet)
prob.model = multinom(formula = active_2014 ~ recency + first_purchase + frequency + avg_amount + max_amount,
                      data = in_sample)

coef = summary(prob.model)$coefficients
std  = summary(prob.model)$standard.errors
print(coef)
print(std)
print(coef / std)

# For the monetary model, select only those who made a purchase
z = which(in_sample$active_2014 == 1)
head(in_sample[z, ])
summary(in_sample[z, ])

# Calibrate the monetary model (version 1)
amount.model = lm(formula = revenue_2014 ~ avg_amount + max_amount, data = in_sample[z, ])
summary(amount.model)

# Plot the results of the monetary model
plot(x = in_sample[z, ]$revenue_2014, y = amount.model$fitted.values)

# Re-calibrate the monetary model, using a log-transform (version 2)
amount.model = lm(formula = log(revenue_2014) ~ log(avg_amount) + log(max_amount), data = in_sample[z, ])
summary(amount.model)

# Plot the results of this new monetary model
plot(x = log(in_sample[z, ]$revenue_2014), y = amount.model$fitted.values)

# Show average revenue per customer and per segment
r = aggregate(x = forward$revenue_2014, by = list(customers_2013$segment), sum)
print(r)

# Re-order and display results
r = r[order(r$x, decreasing = TRUE), ]
print(r)
myBarplot(r, "Average revenue per customer and per segment", "Customer Segments", "Average revenue")
#barplot(r$x, names.arg = r$Group.1, legend.text = round(r$x, 2), xlab = "Customer Segments", ylab = "Average revenue", col = c("darkgreen","green","orange","yellow","darkblue","blue","red"), main="Average revenue per customer and per segment")

# --- COMPUTE TRANSITION MATRIX ------------------------------------------------------------------------------------


# Compute transition matrix
new_data = merge(x = customers_2013, y = customers_2014, by = "customer_id", all.x = TRUE)
head(new_data)
transition = table(new_data$segment.x, new_data$segment.y)
print(transition)

# Divide each row by its sum
transition = transition / rowSums(transition)
print(transition)


# --- USE TRANSITION MATRIX TO MAKE PREDICTIONS --------------------------------------------------------------------


# Initialize a matrix with the number of customers in each segment today and after 10 periods
segments = matrix(nrow = 8, ncol = 11)
segments[, 1] = table(customers_2014$segment)
colnames(segments) = 2014:2024
row.names(segments) = levels(customers_2014$segment)
print(segments)

# Compute for each an every period
for (i in 2:11) {
  segments[, i] = segments[, i-1] %*% transition
}

# Plot inactive, active high value customers over time
barplot(segments[1, ])
barplot(segments[2, ])

# Display how segments will evolve over time
print(round(segments))


# --- COMPUTE THE (DISCOUNTED) CLV OF A DATABASE -------------------------------------------------------------------


# Yearly revenue per segment
# This comes directly from module 2, lines 160-161
yearly_revenue = c(0, 0, 0, 0, 0, 323.57, 52.31, 79.17)

# Compute revenue per segment
revenue_per_segment = yearly_revenue * segments
print(revenue_per_segment)

# Compute yearly revenue
yearly_revenue = colSums(revenue_per_segment)
print(round(yearly_revenue))
barplot(yearly_revenue)

# Compute cumulated revenue
cumulated_revenue = cumsum(yearly_revenue)
print(round(cumulated_revenue))
barplot(cumulated_revenue)

# Create a discount factor
discount_rate = 0.10
discount = 1 / ((1 + discount_rate) ^ ((1:11) - 1))
print(discount)

# Compute discounted yearly revenue
disc_yearly_revenue = yearly_revenue * discount
print(round(disc_yearly_revenue))
barplot(disc_yearly_revenue)
lines(yearly_revenue)

# Compute discounted cumulated revenue
disc_cumulated_revenue = cumsum(disc_yearly_revenue)
print(round(disc_cumulated_revenue))
barplot(disc_cumulated_revenue)

# What is the database worth?
print(disc_cumulated_revenue[11] - yearly_revenue[1])