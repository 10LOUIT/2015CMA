{
    "contents" : "# __________________________________________________________\n# //////////////////////////////////////////////////////////\n#\n#    MODULE 2 - MANAGERIAL SEGMENTATION\n# __________________________________________________________\n# //////////////////////////////////////////////////////////\n\nrm(list=ls(all=TRUE))\nsetwd(\"~/Documents/github/2015CMA/RFM\")\n\n# --- COMPUTING RECENCY, FREQUENCY, MONETARY VALUE ---------\n\n# Load necessary packages\nlibrary(RSQLite)\nlibrary(DBI)\nlibrary(gsubfn)\nlibrary(proto)\nlibrary(tcltk)\n\n# Compute key marketing indicators using SQL language\nlibrary(sqldf)\n\n# Load text file into local variable called 'data'\nsetwd(\"~/OneDrive/B_Data/Berner_PT\")\nraw_data = read.delim(file = 'Customer_purchases_2011_2013_with_empty_amounts.csv', header = FALSE, sep = ',', dec = '.')\n#summary(raw_data)\n\n# Manipulate data of old customers without purchases in this file\nnew_data = sqldf(\"SELECT * FROM raw_data WHERE V3 > 0\")\nold_data = sqldf(\"SELECT * FROM raw_data WHERE V3 = 0\")\nnegative_data = sqldf(\"SELECT * FROM raw_data WHERE V2 < 0\")\nold_data$V3 = \"2010-01-01\" \nold_data$V2 = \"0.00\"\ndata = merge(new_data, old_data, all.x = TRUE, all.y = TRUE)\ndata = sqldf(\"SELECT * FROM raw_data WHERE V2 > -0.01\")\n#data = sqldf(\"SELECT * FROM raw_data WHERE V2 > -0.01 AND V3 NOT LIKE 0\")\n\n# Explore customer data with negative amounts\nnegative_data$V3 = as.Date(negative_data$V3, \"%Y-%m-%d\")\nhist(negative_data$V2)\nsummary(negative_data$V2)\nplot(negative_data$V2, negative_data$V3)\n\n# Cluster Analysis\ncluster_data = negative_data\ncluster_data$V3 = as.numeric(difftime(time1 = \"2014-01-01\",time2 = cluster_data$V3, units = \"days\"))\nclusters = kmeans(cluster_data, 5, 10)\ntable(clusters$size)\nhist(clusters$size)\nplot(clusters$cluster, clusters$fitted.values)\n\n# Filter customers purchases smaller than a distinct threshold \n#data = sqldf(\"SELECT * FROM customers_with_purchases WHERE V2 > 10\")\n#cleand_data = na.omit(raw_data)\n\n# Add headers and interpret the last column as a date, extract year of purchase\ncolnames(data) = c('customer_id', 'purchase_amount', 'date_of_purchase')\ndata$date_of_purchase = as.Date(data$date_of_purchase, \"%Y-%m-%d\")\ndata$year_of_purchase = as.numeric(format(data$date_of_purchase, \"%Y\"))\ndata$days_since       = as.numeric(difftime(time1 = \"2014-01-01\",\n                                            time2 = data$date_of_purchase,\n                                            units = \"days\"))\n\n#thorsten: my rfm segmentation function\nrfmSegmentation <- function(dataInput, orderValueThreshold = 100, endDate = 0) {\n\n  if(endDate == 0) {\n  # Compute recency, frequency, and average purchase amount per customer \n  print(endDate)\n  dataOutput = sqldf(\"SELECT customer_id,\n                         MIN(days_since) AS 'recency',\n                         MAX(days_since) AS 'first_purchase',\n                         COUNT(*) AS 'frequency',\n                         AVG(purchase_amount) AS 'amount'\n                         FROM dataInput GROUP BY 1\")\n } else if(endDate==365) {\n   print(endDate)\n   # must be solved v <- endDate\n   dataOutput = sqldf(\"SELECT customer_id,\n                         MIN(days_since) - 365 AS 'recency',\n                      MAX(days_since) - 365 AS 'first_purchase',\n                      COUNT(*) AS 'frequency',\n                      AVG(purchase_amount) AS 'amount'\n                      FROM dataInput \n                      WHERE days_since > 365\n                      GROUP BY 1\")\n   \n } else if(endDate==730){\n   print(endDate)\n   # must be solved v <- endDate\n   dataOutput = sqldf(\"SELECT customer_id,\n                      MIN(days_since) - 730 AS 'recency',\n                      MAX(days_since) - 730 AS 'first_purchase',\n                      COUNT(*) AS 'frequency',\n                      AVG(purchase_amount) AS 'amount'\n                      FROM dataInput \n                      WHERE days_since > 730\n                      GROUP BY 1\")\n }\n  \n  dataOutput$segment = \"long time inactive\"\n  dataOutput$segment[which(dataOutput$recency > 365*3)] = \"inactive\"\n  dataOutput$segment[which(dataOutput$recency <= 365*3 & dataOutput$recency > 365*2)] = \"cold\"\n  dataOutput$segment[which(dataOutput$recency <= 365*2 & dataOutput$recency > 365*1)] = \"warm\"\n  dataOutput$segment[which(dataOutput$recency <= 365)] = \"active\"\n  dataOutput$segment[which(dataOutput$segment == \"warm\" & dataOutput$first_purchase <= 365*2)] = \"new warm\"\n  dataOutput$segment[which(dataOutput$segment == \"warm\" & dataOutput$amount < orderValueThreshold)] = \"warm low value\"\n  dataOutput$segment[which(dataOutput$segment == \"warm\" & dataOutput$amount >= orderValueThreshold)] = \"warm high value\"\n  dataOutput$segment[which(dataOutput$segment == \"active\" & dataOutput$first_purchase <= 365)] = \"new active\"\n  dataOutput$segment[which(dataOutput$segment == \"active\" & dataOutput$amount < orderValueThreshold)] = \"active low value\"\n  dataOutput$segment[which(dataOutput$segment == \"active\" & dataOutput$amount >= orderValueThreshold)] = \"active high value\"\n \n  \n  dataOutput\n  \n}\n\n#thorsten: my pie chart function\nmyPieChart <- function(dataInput, chartName){\n  # Plot a pie chart\n  mytable <- table(dataInput$segment)\n  slices <- c(mytable)\n  pct <- round(slices/sum(slices)*100, digits = 2)\n  lbls <- paste(names(mytable), \"\\n\", mytable, sep=\"\")\n  lbls <- paste(lbls, \",\", pct) # add percents to labels \n  lbls <- paste(lbls,\"%\",sep=\"\") # ad % to labels \n  pie(mytable, labels = lbls, col = rainbow(length(lbls)), main = chartName)\n}\n\n# Call the rfm segmentation function and return the processed df\n# All Customers\ncustomers <- rfmSegmentation(data, 150)\n# Customers with purchase in 2013\ncustomers_2013 <- rfmSegmentation(data, 150, 0)\n# Customers with purchase in 2012\ncustomers_2012 <- rfmSegmentation(data, 150, 365)\n# Customers with purchase in 2011\ncustomers_2011 <- rfmSegmentation(data, 150, 730)\n# Explore the processed data\ntable(customers$segment)\ntable(customers_2013$segment)\ntable(customers_2012$segment)\ntable(customers_2011$segment)\n\n# --- PREPARING AND TRANSFORMING DATA ----------------------\n\n\n# Copy customer data into new data frame\nnew2_data = sqldf(\"SELECT * FROM customers WHERE amount > 0\")\nsummary(new2_data)\n\n# Remove customer id as a variable, store it as row names\nhead(new2_data)\nrow.names(new2_data) = new_data$customer_id\nnew2_data$customer_id = NULL\nhead(new2_data)\n\n# Take the log-transform of the amount, and plot\nnew_data2$amount = log(new_data$amount)\nhist(new2_data$amount)\n\n# Standardize variables\nnew_data2 = scale(new_data)\nhead(new2_data)\n\n# Call the pie chart functions\nmyPieChart(customers, \"Pie Chart of Customer Segments\\n (Portugal)\")\n\naggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# Display the data after transformation\n#head(data)\n#summary(data)\n\n\n# Compute key marketing indicators using SQL language\n# library(sqldf)\n\n# Compute recency, frequency, and average purchase amount\n# customers_2013 = sqldf(\"SELECT customer_id,\n#                                MIN(days_since) AS 'recency',\n#                                MAX(days_since) AS 'first_purchase',\n#                                COUNT(*) AS 'frequency',\n#                                AVG(purchase_amount) AS 'amount'\n#                         FROM data GROUP BY 1\")\n\n# Explore the data\nhead(customers_2013)\nsummary(customers_2013)\nhist(customers_2013$recency)\nhist(customers_2013$frequency)\nhist(customers_2013$amount)\nhist(customers_2013$amount, breaks = 100)\n\n# --- CODING A MANAGERIAL SEGMENTATION ---------------------\n\n# Simple 2-segment solution based on recency alone\n# customers_2013$segment = ifelse(test = customers_2013$recency > 365*3, yes = \"inactive\", no = \"NA\")\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# A more complex 3-segment solution based on recency alone\n# customers_2013$segment = ifelse(test = customers_2013$recency > 365*3,\n#                            yes = \"inactive\",\n#                            no = ifelse(test = customers_2013$recency > 365*2,\n#                                        yes = \"cold\",\n#                                        no = \"NA\"))\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# Simple 2-segment solution using the which statement\n# customers_2013$segment = \"NA\"\n# customers_2013$segment[which(customers_2013$recency > 365*3)] = \"inactive\"\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# More complex 4-segment solution using which\n# customers_2013$segment = \"NA\"\n# customers_2013$segment[which(customers_2013$recency > 365*3)] = \"inactive\"\n# customers_2013$segment[which(customers_2013$recency <= 365*3 & customers_2013$recency > 365*2)] = \"cold\"\n# customers_2013$segment[which(customers_2013$recency <= 365*2 & customers_2013$recency > 365*1)] = \"warm\"\n# customers_2013$segment[which(customers_2013$recency <= 365)] = \"active\"\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# Complete segment solution using which, and exploiting previous test as input\n# customers_2013$segment = \"NA\"\n# customers_2013$segment[which(customers_2013$recency > 365*3)] = \"inactive\"\n# customers_2013$segment[which(customers_2013$recency <= 365*3 & customers_2013$recency > 365*2)] = \"cold\"\n# customers_2013$segment[which(customers_2013$recency <= 365*2 & customers_2013$recency > 365*1)] = \"warm\"\n# customers_2013$segment[which(customers_2013$recency <= 365)] = \"active\"\n# customers_2013$segment[which(customers_2013$segment == \"warm\" & customers_2013$first_purchase <= 365*2)] = \"new warm\"\n# customers_2013$segment[which(customers_2013$segment == \"warm\" & customers_2013$amount < 100)] = \"warm low value\"\n# customers_2013$segment[which(customers_2013$segment == \"warm\" & customers_2013$amount >= 100)] = \"warm high value\"\n# customers_2013$segment[which(customers_2013$segment == \"active\" & customers_2013$first_purchase <= 365)] = \"new active\"\n# customers_2013$segment[which(customers_2013$segment == \"active\" & customers_2013$amount < 100)] = \"active low value\"\n# customers_2013$segment[which(customers_2013$segment == \"active\" & customers_2013$amount >= 100)] = \"active high value\"\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n# Re-order factor in a way that makes sense\n# customers_2013$segment = factor(x = customers_2013$segment, levels = c(\"inactive\", \"cold\",\n#                                                              \"warm high value\", \"warm low value\", \"new warm\",\n#                                                              \"active high value\", \"active low value\", \"new active\"))\n# table(customers_2013$segment)\n# aggregate(x = customers_2013[, 2:5], by = list(customers_2013$segment), mean)\n\n\n# --- SEGMENTING A DATABASE RETROSPECTIVELY ----------------\n\ncustomers_2012 <- rfmSegmentation(data, 150, 365)\n# Compute key marketing indicators using SQL language\n# library(sqldf)\n# \n# # Compute recency, frequency, and average purchase amount\n# customers_2012 = sqldf(\"SELECT customer_id,\n#                                MIN(days_since) - 365 AS 'recency',\n#                                MAX(days_since) - 365 AS 'first_purchase',\n#                                COUNT(*) AS 'frequency',\n#                                AVG(purchase_amount) AS 'amount'\n#                         FROM data\n#                         WHERE days_since > 365\n#                         GROUP BY 1\")\n# \n# # Complete segment solution using which, and exploiting previous test as input\n# customers_2012$segment = \"NA\"\n# customers_2012$segment[which(customers_2012$recency > 365*3)] = \"inactive\"\n# customers_2012$segment[which(customers_2012$recency <= 365*3 & customers_2012$recency > 365*2)] = \"cold\"\n# customers_2012$segment[which(customers_2012$recency <= 365*2 & customers_2012$recency > 365*1)] = \"warm\"\n# customers_2012$segment[which(customers_2012$recency <= 365)] = \"active\"\n# customers_2012$segment[which(customers_2012$segment == \"warm\" & customers_2012$first_purchase <= 365*2)] = \"new warm\"\n# customers_2012$segment[which(customers_2012$segment == \"warm\" & customers_2012$amount < 100)] = \"warm low value\"\n# customers_2012$segment[which(customers_2012$segment == \"warm\" & customers_2012$amount >= 100)] = \"warm high value\"\n# customers_2012$segment[which(customers_2012$segment == \"active\" & customers_2012$first_purchase <= 365)] = \"new active\"\n# customers_2012$segment[which(customers_2012$segment == \"active\" & customers_2012$amount < 100)] = \"active low value\"\n# customers_2012$segment[which(customers_2012$segment == \"active\" & customers_2012$amount >= 100)] = \"active high value\"\n# \n# # Re-order factor in a way that makes sense\n# customers_2012$segment = factor(x = customers_2012$segment, levels = c(\"inactive\", \"cold\",\n#                                                                        \"warm high value\", \"warm low value\", \"new warm\",\n#                                                                        \"active high value\", \"active low value\", \"new active\"))\n# \n# # Show segmentation results\n# table(customers_2012$segment)\n# pie(table(customers_2012$segment), col = rainbow(24))\n\n# Show segmentation results\nmyPieChart(customers_2012, \"Pie Chart of Customer Segments\\n (Portugal 2012)\")\naggregate(x = customers_2012[, 2:5], by = list(customers_2012$segment), mean)\n\n\n# --- COMPUTING REVENUE GENERATION PER SEGMENT -------------\n\n\n# Compute how much revenue is generated by segments\n# Notice that people with no revenue in 2013 do NOT appear\nrevenue_2013 = sqldf(\"SELECT customer_id, SUM(purchase_amount) AS 'revenue_2013'\n                      FROM data\n                      WHERE year_of_purchase = 2013\n                      GROUP BY 1\")\nsummary(revenue_2013)\n\n# Merge 2013 customers and 2013 revenue (the wrong way)\n# actual = merge(customers_2013, revenue_2013)\n\n# Merge 2013 customers and 2013 revenue (correct)\nactual = merge(customers_2013, revenue_2013, all.x = TRUE)\nactual$revenue_2013[is.na(actual$revenue_2013)] = 0\n\n# Show average revenue per customer and per segment\naggregate(x = actual$revenue_2013, by = list(customers_2013$segment), mean)\n\n# Merge 2012 customers and 2013 revenue (correct)\nforward = merge(customers_2012, revenue_2013, all.x = TRUE)\nforward$revenue_2013[is.na(forward$revenue_2013)] = 0\n\n# Show average revenue per customer and per segment\nr = aggregate(x = forward$revenue_2013, by = list(customers_2012$segment), mean)\nprint(r)\n\n# Re-order and display results\nr = r[order(r$x, decreasing = TRUE), ]\nprint(r)\nbarplot(r$x, names.arg = r$Group.1)\n",
    "created" : 1446402155472.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3774407487",
    "id" : "1324C7AC",
    "lastKnownWriteTime" : 1446403073,
    "path" : "~/Documents/github/2015CMA/RFM/myRFM.R",
    "project_path" : "myRFM.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}